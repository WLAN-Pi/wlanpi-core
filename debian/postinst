#!/bin/bash
# see: dh_installdeb(1)
# dh_installdeb will replace this with shell code automatically
# generated by other debhelper scripts.

#DEBHELPER#

WLANPI_PORT=31415
CONF_CHANGED=0

set -e

function cleanup() {
    if command -v nft >/dev/null 2>&1; then
        nft delete table ip wlanpi_core 2>/dev/null
        nft delete table ip6 wlanpi_core 2>/dev/null
    elif command -v iptables >/dev/null 2>&1; then
        iptables -D INPUT -j wlanpi_core 2>/dev/null
        iptables -X wlanpi_core 2>/dev/null
        ip6tables -D INPUT -j wlanpi_core 2>/dev/null
        ip6tables -X wlanpi_core 2>/dev/null
    fi
    echo "Error: wlanpi-core postinst failed" >&2
    exit 1
}

trap cleanup INT TERM

function isValidSymlink() {
    if [ -L "$1" ]; then
        return 0
    else
        return 1
    fi
}

if systemctl is-masked var-log-wlanpi_core-debug.mount >/dev/null 2>&1; then
    echo "Unmasking var-log-wlanpi_core-debug.mount..."
    systemctl unmask var-log-wlanpi_core-debug.mount || true
fi

if ! command -v python3 >/dev/null 2>&1; then
    echo "Error: python3 not found" >&2
    exit 1
fi

if ! PYTHONSTUB=$(python3 -V 2>&1 | sed 's/ //g' | grep -oP '(\w+\.\d+)' | tr 'P' 'p'); then
    echo "Error: Failed to determine Python version" >&2
    exit 1
fi

if [ -z "$PYTHONSTUB" ]; then
    echo "Error: Could not parse Python version" >&2
    exit 1
fi

# the actual target working directory (this is a workaround so we can support multiple Python versions at build)
TARGET_DIR=/opt/wlanpi-core/lib/$PYTHONSTUB/site-packages/wlanpi_core

# this is the parent directory which holds our linked working directory
LINK=/opt/wlanpi-core/workingdirectory

# this is the path that we need to check if is already a link
TEST_PATH=/opt/wlanpi-core/workingdirectory/wlanpi_core

# if link doesn't exist, create it
if ! isValidSymlink $TEST_PATH; then
    ln -sf "$TARGET_DIR" "$LINK"
fi

# if conf is not a symlink, and exists as a file, create backup.
NGINX_CONF=/etc/nginx/nginx.conf
if ! isValidSymlink $NGINX_CONF; then
    if [ -f "$NGINX_CONF" ]; then
        TSTAMP=$(date '+%s')
        NEW_CONF="$NGINX_CONF.$TSTAMP"
        echo "Existing nginx.conf detected; backing it up and moving it to $NEW_CONF..."
        mv "$NGINX_CONF" "$NEW_CONF"
    fi
    echo "Linking our nginx.conf config ..."
    ln -s /etc/wlanpi-core/nginx/nginx.conf $NGINX_CONF
    CONF_CHANGED=1
fi

# if default site is enabled, disable it.
DEFAULT_FILE=/etc/nginx/sites-enabled/default
if isValidSymlink $DEFAULT_FILE; then
    echo "Unlinking $DEFAULT_FILE"
    unlink $DEFAULT_FILE
fi

if [ ! -f /etc/nginx/ssl/self-signed-wlanpi.cert ] || [ ! -f /etc/nginx/ssl/self-signed-grafana.cert ] || [ ! -f /etc/cockpit/ws-certs.d/0-self-signed-wlanpi.cert ]; then
    mkdir -p /etc/nginx/ssl
    mkdir -p /etc/cockpit/ws-certs.d
    if ! openssl req -x509 -newkey rsa:4096 -sha256 -days 3650 \
        -nodes -keyout /etc/nginx/ssl/self-signed-wlanpi.key \
        -out /etc/nginx/ssl/self-signed-wlanpi.cert \
        -subj "/CN=wlanpi.local/O=wlanpi/OU=wlanpi"; then
        echo "Error: Failed to generate SSL certificate"
        exit 1
    fi
    chmod 654 /etc/nginx/ssl/self-signed-wlanpi.cert
    chmod 650 /etc/nginx/ssl/self-signed-wlanpi.key
    /bin/cp /etc/nginx/ssl/self-signed-wlanpi.key /etc/cockpit/ws-certs.d/0-self-signed-wlanpi.key
    /bin/cp /etc/nginx/ssl/self-signed-wlanpi.cert /etc/cockpit/ws-certs.d/0-self-signed-wlanpi.cert
    /bin/cp /etc/nginx/ssl/self-signed-wlanpi.key /etc/nginx/ssl/self-signed-grafana.key
    /bin/cp /etc/nginx/ssl/self-signed-wlanpi.cert /etc/nginx/ssl/self-signed-grafana.cert
    chmod 654 /etc/nginx/ssl/self-signed-grafana.cert
    chmod 650 /etc/nginx/ssl/self-signed-grafana.key
    getent group grafana || groupadd grafana
    chgrp grafana /etc/nginx/ssl/self-signed-grafana.key
    chgrp grafana /etc/nginx/ssl/self-signed-grafana.cert
    CONF_CHANGED=1
fi

if ! getent group wlanpi >/dev/null; then
    echo "Error: wlanpi group does not exist" >&2
    exit 1
fi

chgrp wlanpi /etc/nginx/ssl/self-signed-wlanpi.key
chgrp wlanpi /etc/nginx/ssl/self-signed-wlanpi.cert

# Ensure nginx sites-enabled directory exists
mkdir -p /etc/nginx/sites-enabled

# if source configuration file exists, create symlink
WLANPI_CORE=/etc/nginx/sites-enabled/wlanpi_core.conf
SOURCE_CONF=/etc/wlanpi-core/nginx/sites-enabled/wlanpi_core.conf

if [ -f "$SOURCE_CONF" ]; then
    ln -sf "$SOURCE_CONF" "$WLANPI_CORE" || true
    CONF_CHANGED=1
else
    echo "Warning: source nginx site configuration at $SOURCE_CONF not found"
fi

if ! ischroot; then
    if [ $CONF_CHANGED -eq 1 ]; then
        echo "Restarting wlanpi-core ..."
        systemctl start var-log-wlanpi_core-debug.mount || true
        deb-systemd-invoke restart wlanpi-core.service
        if which nginx; then
            echo "Restarting nginx ..."
            deb-systemd-invoke restart nginx.service
        fi
    fi
fi

if [ -f /usr/bin/getjwt ]; then
    chmod 755 /usr/bin/getjwt
fi

if [ -f /usr/bin/lhapitest ]; then
    chmod 755 /usr/bin/lhapitest
fi

if command -v nft >/dev/null 2>&1; then
    # Use nftables for IPv4
    if ! nft list table ip wlanpi_core >/dev/null 2>&1; then
        if ! nft add table ip wlanpi_core; then
            echo "Error: Failed to create IPv4 nftables table" >&2
            exit 1
        fi
        if ! nft "add chain ip wlanpi_core input { type filter hook input priority 0; }"; then
            echo "Error: Failed to create IPv4 nftables chain" >&2
            nft delete table ip wlanpi_core
            exit 1
        fi
        if ! nft "add rule ip wlanpi_core input tcp dport ${WLANPI_PORT} accept"; then
            echo "Error: Failed to add IPv4 TCP rule" >&2
            nft delete table ip wlanpi_core
            exit 1
        fi
        if ! nft "add rule ip wlanpi_core input udp dport ${WLANPI_PORT} accept"; then
            echo "Error: Failed to add IPv4 UDP rule" >&2
            nft delete table ip wlanpi_core
            exit 1
        fi
        echo "[Network] Port ${WLANPI_PORT}: IPv4 firewall rules successfully configured with nftables."
    fi

    # Use nftables for IPv6
    if ! nft list table ip6 wlanpi_core >/dev/null 2>&1; then
        if ! nft add table ip6 wlanpi_core; then
            echo "Error: Failed to create IPv6 nftables table" >&2
            exit 1
        fi
        if ! nft "add chain ip6 wlanpi_core input { type filter hook input priority 0; }"; then
            echo "Error: Failed to create IPv6 nftables chain" >&2
            nft delete table ip6 wlanpi_core
            exit 1
        fi
        if ! nft "add rule ip6 wlanpi_core input tcp dport ${WLANPI_PORT} accept"; then
            echo "Error: Failed to add IPv6 TCP rule" >&2
            nft delete table ip6 wlanpi_core
            exit 1
        fi
        if ! nft "add rule ip6 wlanpi_core input udp dport ${WLANPI_PORT} accept"; then
            echo "Error: Failed to add IPv6 UDP rule" >&2
            nft delete table ip6 wlanpi_core
            exit 1
        fi
        echo "[Network] Port ${WLANPI_PORT}: IPv6 firewall rules successfully configured with nftables."
    fi
# Fall back to iptables if nft isn't available
elif command -v iptables >/dev/null 2>&1 && command -v ip6tables >/dev/null 2>&1; then
    # IPv4 Configuration
    if ! iptables -L wlanpi_core >/dev/null 2>&1; then
        if ! iptables -N wlanpi_core; then
            echo "Error: Failed to create IPv4 iptables chain" >&2
            exit 1
        fi
        if ! iptables -A INPUT -j wlanpi_core; then
            echo "Error: Failed to add IPv4 chain to INPUT" >&2
            iptables -X wlanpi_core
            exit 1
        fi
    fi
    
    if ! iptables -C wlanpi_core -p tcp --dport ${WLANPI_PORT} -j ACCEPT 2>/dev/null; then
        if ! iptables -I wlanpi_core -p tcp --dport ${WLANPI_PORT} -j ACCEPT; then
            echo "Error: Failed to add IPv4 TCP rule" >&2
            iptables -D INPUT -j wlanpi_core
            iptables -X wlanpi_core
            exit 1
        fi
        echo "[Network] TCP port ${WLANPI_PORT}: IPv4 firewall rule successfully configured."
    fi

    if ! iptables -C wlanpi_core -p udp --dport ${WLANPI_PORT} -j ACCEPT 2>/dev/null; then
        if ! iptables -I wlanpi_core -p udp --dport ${WLANPI_PORT} -j ACCEPT; then
            echo "Error: Failed to add IPv4 UDP rule" >&2
            iptables -D INPUT -j wlanpi_core
            iptables -X wlanpi_core
            exit 1
        fi
        echo "[Network] UDP port ${WLANPI_PORT}: IPv4 firewall rule successfully configured."
    fi

    # IPv6 Configuration
    if ! ip6tables -L wlanpi_core >/dev/null 2>&1; then
        if ! ip6tables -N wlanpi_core; then
            echo "Error: Failed to create IPv6 iptables chain" >&2
            exit 1
        fi
        if ! ip6tables -A INPUT -j wlanpi_core; then
            echo "Error: Failed to add IPv6 chain to INPUT" >&2
            ip6tables -X wlanpi_core
            exit 1
        fi
    fi
    
    if ! ip6tables -C wlanpi_core -p tcp --dport ${WLANPI_PORT} -j ACCEPT 2>/dev/null; then
        if ! ip6tables -I wlanpi_core -p tcp --dport ${WLANPI_PORT} -j ACCEPT; then
            echo "Error: Failed to add IPv6 TCP rule" >&2
            ip6tables -D INPUT -j wlanpi_core
            ip6tables -X wlanpi_core
            exit 1
        fi
        echo "[Network] TCP port ${WLANPI_PORT}: IPv6 firewall rule successfully configured."
    fi

    if ! ip6tables -C wlanpi_core -p udp --dport ${WLANPI_PORT} -j ACCEPT 2>/dev/null; then
        if ! ip6tables -I wlanpi_core -p udp --dport ${WLANPI_PORT} -j ACCEPT; then
            echo "Error: Failed to add IPv6 UDP rule" >&2
            ip6tables -D INPUT -j wlanpi_core
            ip6tables -X wlanpi_core
            exit 1
        fi
        echo "[Network] UDP port ${WLANPI_PORT}: IPv6 firewall rule successfully configured."
    fi
else
    echo "Warning: Neither nftables nor iptables found" >&2
    exit 1
fi

exit 0
